##### 匹配位置
> ^和$

- ^从开头匹配，在多行匹配中匹配行开头
- $从结尾开始匹配，在多行匹配中匹配行结尾
- 实例：
    - 匹配字符串开头和结尾
    ```
    var string = 'hello, how old are you?'
    var result = string.replace(/^h|$/, 'H');
    console.log(result); // Hello, how old are you?
    ```
    `/^h|$/`表示匹配以字符串h的开头位置


> `\b`和`\B`

- `\b`是单词边界，具体是`\w`和`\W`之间的位置，也包括`\w`和`^`之间的位置，也包括`\w`和$之间的位置。比如一个文件名是"[JS] Lesson_01.mp4"中的\b，如下：
```
var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
console.log(result); 
// => "[#JS#] #Lesson_01#.#mp4#"
```
为什么是这样呢？这需要仔细看看。 

首先，我们知道，\w是字符组[0-9a-zA-Z_]的简写形式，即\w是字母数字或者下划线的中任何一个字符。而\W是排除字符组[^0-9a-zA-Z_]的简写形式，即\W是\w以外的任何一个字符。  

此时我们可以看看"[#JS#] #Lesson_01#.#mp4#"中的每一个"#"，是怎么来的。
- 第一个"#"，两边是"["与"J"，是\W和\w之间的位置。
- 第二个"#"，两边是"S"与"]"，也就是\w和\W之间的位置。
- 第三个"#"，两边是空格与"L"，也就是\W和\w之间的位置。
- 第四个"#"，两边是"1"与"."，也就是\w和\W之间的位置。
- 第五个"#"，两边是"."与"m"，也就是\W和\w之间的位置。
- 第六个"#"，其对应的位置是结尾，但其前面的字符"4"是\w，即\w和$之间的位置。

知道了\b的概念后，那么\B也就相对好理解了。

\B就是\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。

具体说来就是\w与\w、\W与\W、^与\W，\W与$之间的位置。

比如上面的例子，把所有\B替换成"#"：
```
var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');
console.log(result); 
// => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

> `(?=p)`和`(?!p)`

`p`是子模式。`(?=p)`表示`p`前面的位置。如：`?=love`的意思就是字符串love前面的位置。而`(?!p)`是`(?=p)`的取反。    `(?!love)`表示除了`love`前面的位置的其他所有位置 
```
console.log('word'.replace(/(?!o)/g, '#')); // #wo#r#d#
console.log('word'.replace(/(?!o)/, '#')); // #word (匹配到第一个o，停止了匹配，所以只有在开头才有#)
```
> 案例

- 数字的千位分隔符表示法。比如："12345678"，变成"12,345,678"。
    - 思路：1.从结尾开始匹配 ：`/\d{3}$/g` 2. 找到位置：`/(?=\d{3}$)/g`。3.至少匹配1次：`/(?=\d{3})+$/g` 4.开头不匹配：`/(?!^)(?=\d{3})+$/g`。所以，最终的表达式：`/(?!^)(?=\d{3})+$/g`
    - 测试一波
    ```
    var string1 = "12345678";
    var string2 = "123456789";
    var reg = /(?!^)(?=(\d{3})+$)/g;
    
    var result = string1.replace(reg, ',')
    console.log(result); 
    // => "12,345,678"
    
    result = string2.replace(reg, ',');
    console.log(result); 
    // => "123,456,789"
   ```
- 验证密码问题。密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符
    - 思路：
        - 1.忽略'但必须至少包括2种字符'这个条件 有`/^[0-9A-Za-z]{6,12}$/g`。
        - 2.判断包含数字：  `/(?=.*[0-9])^[0-9A-Za-z]{6,12}$/`。`(?=.*[0-9])^`表示开头`^`前面还有字符（也就是空字符）。`(?=.*[0-9])`表示该位置后面的字符匹配`.*[0-9]`。即，有任何多个任意字符，后面再跟个数字。翻译成大白话，就是接下来的字符，必须包含个数字。这样写保证了一定是从头开始匹配的。理解完这个。接下来就简单了。
        - 3-1包含数字和小写字母：`/(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/`
        - 3-2包含数字和大写字母：`/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])^[0-9A-Za-z]{6,12}$/`
        - 3-3包含大写字母和小写字母：`/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/`
    - 最终的实现：`/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/`
    - 测试一波：
    ```
    var reg = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/;
    console.log( reg.test("1234567") ); // false 全是数字
    console.log( reg.test("abcdef") ); // false 全是小写字母
    console.log( reg.test("ABCDEFGH") ); // false 全是大写字母
    console.log( reg.test("ab23C") ); // false 不足6位
    console.log( reg.test("ABCDEF234") ); // true 大写字母和数字
    console.log( reg.test("abcdEF234") ); // true 三者都有
    ```
