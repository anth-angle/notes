- 模糊匹配
    - 横向模糊匹配：匹配的字符串长度不固定 如：`/ab{1, 3} c/` 表示匹配`abc`,`abbc`, `abbbc`
    - 纵向模糊匹配：某个字符不确定 如： `/a[12]c/` 表示匹配：`a1c`, `a2c`中的任意一个
- 字符组
    - 形式: `[abc]` 凡是由中括号`[]`括起来的,均是字符组。
    - 表示匹配字符组中的任意**一个字符**。如：`[ab]`表示匹配a或者b （如何匹配数字12呢？）
- 量词


|形式|描述|
|-|-|
|{m,}|表示至少出现m次|
|{m}|等价于{m, m},表示出现m次|
|?|等价于{0, 1}, 表示出现或者不出现，记忆方式：问号? => 有吗？|
|+|等价于{1,}, 表示至少出现一次|
|*|等价于{0,}, 表示出现任意次|

- 贪婪匹配和惰性匹配
```
var regexp = /\d{2,5}/;
var string = '123 1234 12345';
console.log(string.match(regexp)); // ['123', '1234', '12345']
```
`/\d{2,5}/`表示匹配**连续出现**2到5次的数字。但它是贪婪的，会尽可能匹配连续出现2次以上（包括2次）直到5次的数字。而惰性匹配刚好相反，尽可能少匹配：
```
var regexp = /\d{2,5}?/;
var string = '123 1234 12345';
console.log(string.match(regexp)); // ['12', '12', '34' '12', '34']
```
其中 `/\d{2,5}?/`表示：虽然匹配范围是2-5，但2个就可以达到及格线了，不用往下继续尝试了  

通过在量词后台加个问号就能实现惰性匹配，因此，所有的惰性匹配形式如下：
> {m,n}?  
{m,}?  
??  
+?  
*?

- 分支结构（多选）

|形式|描述|跟字符组的区别|
|-|-|-|
|`(p1|p2|p3)`|p1,p,p3..表示子模式，用`|`分隔，表示匹配其中任意一个子模式|字符组只能匹配任意字符（单个），而多选可以匹配任意字符串
```
var regexp = /good|nice/g;
var string =  'good day, nice to meet you';
console.log(string.match(regexp)); // ["good", "nice"]
```
注意的地方：分支结构是惰性匹配的
```
var regexp = /good|goodbye/g;
var string =  'goodbye good for you';
console.log(string.match(regexp)); // ["good", "good"]
```
把正则改为`/goodbye|good/`，结果：
```
var regexp = /goodbye|good/g;
var string =  'goodbye good for you';
console.log(string.match(regexp)); // ["goodbye", "good"]
```
- 实例
    - 匹配类似这样的'2008-08-08'格式
        - 年份是4位数，可以：`[0-9]{4}`
        - 月份是2位数，有01-09和10-12两种情况。所以：`0[1-9]|1[0-2]`
        - 日 1-31天。有01-09、10-29和30-31三种情况。则：`0[1-9]|[12][0-9]|3[01]`
        - 所以，最终的表达式：`/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/`
        - 测试一波：
        ```
        var regexp = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/g;
        var string = '2001-06-30';
        console.log(regexp.test(string)); // true
        ```